package ifacecodegen

import (
	"strings"
	"testing"
)

func TestGenerate(t *testing.T) {
	pkg := &Package{
		Name: "foo",
		Interfaces: []*Interface{
			&Interface{
				Name: "Service",
				Methods: []*Method{
					&Method{
						Name: "Foo",
						In: []*Parameter{
							&Parameter{
								Name: "param1",
								Type: TypeBuiltin("string"),
							},
						},
						Out: []*Parameter{
							&Parameter{
								Name: "result1",
								Type: &TypeExported{
									Package: "foo",
									Type:    TypeBuiltin("Bar"),
								},
							},
						},
					},
				},
			},
		},
	}

	opts := GenerateOptions{
		Package: pkg,
		Imports: []*Import{
			&Import{
				Package: "github.com/bar/foo",
				Path:    "foo",
			},
		},
		Meta: map[string]string{
			"service": "account",
		},
		Template: strings.NewReader(`
type logger{{ .Name }} struct {
	s {{ .Name }}
}

{{ $ifaceRef := . }}
{{ range .Methods }}
func (w *logger{{ $ifaceRef.Name }}) {{ .Name }}({{ input_parameters . }}) {{ $methodRef := . }}{{ output_parameters . }} {
		defer func(begin time.Time) {
			var err error {{ if ne (output_var_error .) "" -}}
			 = {{ output_var_error . }}
			{{- end }}
			log.Print("service", "{{ meta "service" }}", "took", time.Since(begin), "error", err)
		}(time.Now())
		{{ return . }} w.s.{{ .Name }}({{ input_calls . }})
}

{{ end }}

`),
	}

	content, err := Generate(opts)

	if err != nil {
		t.Fatalf("Error should be nil, actual %v", err)
	}

	expected := `// Code generated by ifacecodegen tool. DO NOT EDIT.
// Source:

package foo

import (
	"log"
	"time"
)

type loggerService struct {
	s Service
}

func (w *loggerService) Foo(param1 string) (result1 Bar) {
	defer func(begin time.Time) {
		var err error
		log.Print("service", "account", "took", time.Since(begin), "error", err)
	}(time.Now())
	return w.s.Foo(param1)
}
`
	if actual := string(content); actual != expected {
		t.Errorf("expected '%s', actual '%s'", expected, actual)
	}

}
